/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

// ====================================================================================
// 异步辅助函数
// ====================================================================================

/**
 * TypeScript 编译生成的异步等待辅助函数。
 * 用于处理 async/await 的状态机。
 */
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * 错误抑制处理函数。
 * 用于处理 Promise 中的错误抑制情况。
 */
typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// ====================================================================================
// Obsidian 视图与编辑器辅助函数
// ====================================================================================

/**
 * 获取当前活跃的 Markdown 视图。
 * @param {App} app Obsidian 应用实例
 * @returns {MarkdownView | undefined} 返回活跃的 MarkdownView，如果不存在则返回 undefined
 */
function getActiveView(app) {
    const activeView = app.workspace.getActiveViewOfType(obsidian.MarkdownView);
    return activeView !== null && activeView !== void 0 ? activeView : undefined;
}

/**
 * 检查当前是否有活跃的 Markdown 视图且包含文件。
 * @param {App} app 
 * @returns {boolean}
 */
function isViewActive(app) {
    const activeView = getActiveView(app);
    if (activeView && activeView.file)
        return true;
    return false;
}

/**
 * 获取当前活跃视图文件的元数据缓存。
 * @param {App} app 
 * @returns {CachedMetadata | undefined}
 */
function getViewMetadata(app) {
    const activeView = getActiveView(app);
    if (activeView && activeView.file) {
        const data = app.metadataCache.getFileCache(activeView.file) || {};
        return data;
    }
    return undefined;
}

/**
 * 聚合获取当前视图、元数据和编辑器实例。
 * @param {App} app 
 * @returns {{activeView: MarkdownView, data: CachedMetadata, editor: Editor} | undefined}
 */
function getViewInfo(app) {
    const activeView = getActiveView(app);
    const data = getViewMetadata(app);
    const editor = activeView ? activeView.editor : undefined;
    if (activeView && data && editor) {
        return {
            activeView, data, editor
        };
    }
    return undefined;
}

/**
 * 恢复编辑器光标位置。
 * 用于在自动更新编号导致文档内容变更后，将用户光标重置回变更前的位置，避免跳动。
 * 包含边界检查，防止光标设置到不存在的行或字符位置。
 * * @param {Editor} editor 编辑器实例
 * @param {EditorPosition} cursor 保存的光标位置对象 {line, ch}
 */
function restoreCursor(editor, cursor) {
    try {
        const lineCount = editor.lineCount();
        if (cursor.line < lineCount) {
            const lineLength = editor.getLine(cursor.line).length;
            if (cursor.ch <= lineLength) {
                editor.setCursor(cursor);
            }
            else {
                editor.setCursor(cursor.line, lineLength); // 如果原位置超出当前行长度，则设置到行尾
            }
        }
    }
    catch (e) {
        console.log("Number Headings Plugin: Error restoring cursor", e);
    }
}

// ====================================================================================
// 编号系统常量与核心逻辑
// ====================================================================================

// 中文数字映射表 (用于 '一' 样式)
const chineseNumbers = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十'];
// 带圈数字映射表 (用于 '①' 样式)
const circledNumbers = ['⓪', '①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱', '⑲', '⑳'];

/**
 * 验证字符串是否为有效的阿拉伯数字。
 * @param {string} s 
 * @returns {boolean}
 */
function isValidArabicNumberingValueString(s) {
    const regex = /^[0-9]+$/;
    return regex.test(s);
}

/**
 * 获取文档中所有代码块的行号范围。
 * 基于 Obsidian 的 CachedMetadata。
 * @param {CachedMetadata} data 
 * @returns {Array<{start: number, end: number}>}
 */
function getCodeBlockRanges(data) {
    if (!data || !data.sections) return [];
    return data.sections
        .filter(section => section.type === 'code')
        .map(section => ({
            start: section.position.start.line,
            end: section.position.end.line
        }));
}

/**
 * 检查指定行是否应被忽略（位于代码块内或表格行中）。
 * @param {number} lineNum 行号
 * @param {string} lineText 行文本
 * @param {Array<{start: number, end: number}>} codeRanges 代码块范围列表
 * @returns {boolean}
 */
function isLineIgnored(lineNum, lineText, codeRanges) {
    // 1. 检查是否在代码块范围内
    for (const range of codeRanges) {
        if (lineNum >= range.start && lineNum <= range.end) {
            return true;
        }
    }

    // 2. 检查是否为表格行 (以 | 开头，允许前导空格)
    // 注意：这将忽略表格内的所有内容，包括公式
    const tableRegex = /^\s*\|/;
    if (tableRegex.test(lineText)) {
        return true;
    }

    return false;
}

/**
 * 根据样式获取“零值”Token。
 * 用于计算编号的前一个状态 (例如 1 的前一个是 0, A 的前一个是 @/Z)。
 * * @param {string} style 编号样式 ('1', 'A', 'a', etc.)
 * @param {string} startValue 起始值
 * @returns {{style: string, value: any}}
 */
function zerothNumberingTokenInStyle(style, startValue) {
    switch (style) {
        case '1':
            return { style: '1', value: parseInt(startValue) - 1 || 0 };
        case 'A':
            // 字母回退逻辑：如果起始是 'A'，前一个设为 'Z' (作为一种循环标记)，或者 ASCII 码减 1
            if (startValue === 'A') return { style: 'A', value: 'Z' };
            else return { style: 'A', value: String.fromCharCode(startValue.charCodeAt(0) - 1) };
        case 'a':
            if (startValue === 'a') return { style: 'a', value: 'z' };
            else return { style: 'a', value: String.fromCharCode(startValue.charCodeAt(0) - 1) };
    }
    // 默认回退逻辑
    return { style: '1', value: parseInt(startValue) - 1 || 0 };
}

/**
 * 获取特定样式的起始编号 Token。
 * 处理不同样式下起始值为数字或字符的转换逻辑，特别是支持 '0' 作为起始值的情况。
 * * @param {string} style 编号样式 ('1', 'A', 'a', '一', '①')
 * @param {string} startValue 用户设置的起始值字符串
 * @returns {{style: string, value: any}}
 */
function firstNumberingTokenInStyle(style, startValue) {
    const startNum = parseInt(startValue);
    const isNumericStart = !isNaN(startNum);

    switch (style) {
        case '1':
            return { style: '1', value: startNum }; // 直接支持 0 或正整数
        case 'A':
            if (isNumericStart) {
                // 特殊处理：0 -> '&' (A的前一位), >0 -> 计算对应字母
                if (startNum === 0) return { style: 'A', value: '&' };
                if (startNum > 0) return { style: 'A', value: String.fromCharCode('A'.charCodeAt(0) + startNum - 1) };
                return { style: 'A', value: 'A' }; // 负数回退
            }
            return { style: 'A', value: startValue || 'A' };
        case 'a':
            if (isNumericStart) {
                if (startNum === 0) return { style: 'a', value: '&' };
                if (startNum > 0) return { style: 'a', value: String.fromCharCode('a'.charCodeAt(0) + startNum - 1) };
                return { style: 'a', value: 'a' };
            }
            return { style: 'a', value: startValue || 'a' };
        case '一':
            if (isNumericStart) {
                // 映射数字索引到中文数组
                if (startNum >= 0 && startNum < chineseNumbers.length) {
                    return { style: '一', value: chineseNumbers[startNum] };
                }
                // 溢出数组则直接使用数字字符串 (如 '11')
                if (startNum >= chineseNumbers.length) {
                    return { style: '一', value: String(startNum) };
                }
                return { style: '一', value: '一' };
            }
            return { style: '一', value: startValue || '一' };
        case '①':
            if (isNumericStart) {
                if (startNum >= 0 && startNum < circledNumbers.length) {
                    return { style: '①', value: circledNumbers[startNum] };
                }
                if (startNum >= circledNumbers.length) {
                    return { style: '①', value: String(startNum) };
                }
                return { style: '①', value: '①' };
            }
            return { style: '①', value: startValue || '①' };
    }
    // 默认回退到数字样式
    return { style: '1', value: startNum };
}

/**
 * 计算下一个编号 Token。
 * 实现了各样式的自增逻辑。
 * * @param {{style: string, value: any}} t 当前 Token
 * @returns {{style: string, value: any}} 下一个 Token
 */
function nextNumberingToken(t) {
    switch (t.style) {
        case '1':
            return { style: '1', value: t.value + 1 };
        case 'A':
            if (t.value === '&') return { style: 'A', value: 'A' }; // & -> A
            if (t.value === 'Z') return { style: 'A', value: 'A' }; // Z -> A (循环或重置)
            else return { style: 'A', value: String.fromCharCode(t.value.charCodeAt(0) + 1) };
        case 'a':
            if (t.value === '&') return { style: 'a', value: 'a' }; // & -> a
            if (t.value === 'z') return { style: 'a', value: 'a' }; // z -> a
            else return { style: 'a', value: String.fromCharCode(t.value.charCodeAt(0) + 1) };
        case '一':
            const currentIndex = chineseNumbers.indexOf(t.value);
            // 在数组范围内递增
            if (currentIndex > -1 && currentIndex < chineseNumbers.length - 1) {
                return { style: '一', value: chineseNumbers[currentIndex + 1] };
            }
            // 处理边界 '十' -> '11'
            if (currentIndex === chineseNumbers.length - 1) {
                return { style: '一', value: '11' };
            }
            // 处理数字形式 '11' -> '12'
            const num = parseInt(t.value);
            if (!isNaN(num)) {
                return { style: '一', value: String(num + 1) };
            }
            return { style: '一', value: '一' };
        case '①':
            const circledIndex = circledNumbers.indexOf(t.value);
            if (circledIndex > -1 && circledIndex < circledNumbers.length - 1) {
                return { style: '①', value: circledNumbers[circledIndex + 1] };
            }
            // 处理边界 '⑳' -> '21'
            if (circledIndex === circledNumbers.length - 1) {
                return { style: '①', value: '21' };
            }
            // 处理数字形式 '21' -> '22'
            const circledNum = parseInt(t.value);
            if (!isNaN(circledNum)) {
                return { style: '①', value: String(circledNum + 1) };
            }
            return { style: '①', value: '①' };
    }
    return { style: '1', value: t.value + 1 };
}

/**
 * 计算上一个编号 Token。
 * 实现了各样式的自减逻辑，主要用于确定起始状态。
 */
function previousNumberingToken(t) {
    switch (t.style) {
        case '1':
            return { style: '1', value: t.value - 1 };
        case 'A':
            if (t.value === 'A') return { style: 'A', value: '&' }; // A -> &
            if (t.value === '&') return { style: 'A', value: 'Z' }; // & -> Z
            else return { style: 'A', value: String.fromCharCode(t.value.charCodeAt(0) - 1) };
        case 'a':
            if (t.value === 'a') return { style: 'a', value: '&' }; // a -> &
            if (t.value === '&') return { style: 'a', value: 'z' }; // & -> z
            else return { style: 'a', value: String.fromCharCode(t.value.charCodeAt(0) - 1) };
        case '一':
            // 处理 '12' -> '11', '11' -> '十'
            const num = parseInt(t.value);
            if (!isNaN(num)) {
                if (num > 11) return { style: '一', value: String(num - 1) };
                if (num === 11) return { style: '一', value: '十' };
            }
            // 处理数组内回退
            const currentIndex = chineseNumbers.indexOf(t.value);
            if (currentIndex > 0) {
                return { style: '一', value: chineseNumbers[currentIndex - 1] };
            }
            return { style: '一', value: '零' };
        case '①':
            // 处理 '22' -> '21', '21' -> '⑳'
            const circledNum = parseInt(t.value);
            if (!isNaN(circledNum)) {
                if (circledNum > 21) return { style: '①', value: String(circledNum - 1) };
                if (circledNum === 21) return { style: '①', value: '⑳' };
            }
            // 处理数组内回退
            const circledIndex = circledNumbers.indexOf(t.value);
            if (circledIndex > 0) {
                return { style: '①', value: circledNumbers[circledIndex - 1] };
            }
            return { style: '①', value: '⓪' };
    }
    return { style: '1', value: t.value - 1 };
}

/**
 * 将 Token 转换为可打印字符串。
 */
function printableNumberingToken(t) {
    switch (t.style) {
        case '1':
            return t.value.toString();
        case 'A':
        case 'a':
        case '一':
        case '①':
            return t.value;
    }
    return t.value.toString();
}

/**
 * 构建完整的编号字符串。
 * 根据当前的编号栈和各级分隔符设置，拼接出如 "1.1-A" 这样的字符串。
 * * @param {Array} numberingStack 编号栈
 * @param {Array} separators 分隔符数组
 * @returns {string}
 */
function makeNumberingString(numberingStack, separators) {
    let numberingString = '';
    for (let i = 0; i < numberingStack.length; i++) {
        if (i === 0) {
            numberingString += ' '; // H1 前强制添加空格
        }
        else {
            // 添加对应层级的分隔符
            numberingString += separators[i] || '';
        }
        numberingString += printableNumberingToken(numberingStack[i]);
    }
    return numberingString;
}

/**
 * 辅助函数：根据设置决定起始值或默认零值。
 */
function startAtOrZerothInStyle(startAtSettingString, style, startValue) {
    if (startAtSettingString === '')
        return zerothNumberingTokenInStyle(style, startValue);
    let firstNumberingTokenFromSetting;

    // 简化的分支逻辑，主要处理数字和字母的解析
    if (style === '1' || (!['A', 'a'].includes(style))) {
        if (!isValidArabicNumberingValueString(startAtSettingString))
            return zerothNumberingTokenInStyle(style, startValue);
        firstNumberingTokenFromSetting = { style: '1', value: parseInt(startAtSettingString) };
    } else if (style === 'A') {
        if (!isValidAlphabetNumberingValueString(startAtSettingString))
            return zerothNumberingTokenInStyle(style, startValue);
        firstNumberingTokenFromSetting = { style: 'A', value: startAtSettingString };
    } else if (style === 'a') {
        if (!isValidAlphabetNumberingValueString(startAtSettingString.toLowerCase()))
            return zerothNumberingTokenInStyle(style, startValue);
        firstNumberingTokenFromSetting = { style: 'a', value: startAtSettingString };
    }

    return previousNumberingToken(firstNumberingTokenFromSetting);
}

// ====================================================================================
// 插件配置与 FrontMatter 解析
// ====================================================================================

// 默认设置对象
const DEFAULT_SETTINGS = {
    skipTopLevel: false,         // 是否跳过一级标题 (该字段目前逻辑中保留但UI未暴露)
    firstLevel: 1,               // 起始编号级别 (H1-H6)
    maxLevel: 6,                 // 最大编号级别
    auto: false,                 // 是否开启自动标题编号
    skipHeadings: '',            // 跳过特定文本结尾的标题
    off: false,                  // 是否完全关闭插件功能
    equationNumberingMode: 'continuous', // 公式编号模式: 'continuous'(连续) 或 'heading-based'(基于标题)
    autoNumberFormulas: false,   // 是否开启自动公式编号
    refreshInterval: 1000,         // 自动更新检测间隔 (毫秒)
    headingStyles: ['1', 'a', 'A', '一', '①', '1'], // 1-6级标题的具体样式
    headingSeparators: ['', '-', ':', '.', '—', '-'], // 1-6级的分隔符 (索引0为H1前缀)
    headingStartValues: ['0', '1', '1', '1', '1', '1'], // 1-6级的起始值
    equationNumberingMaxDepth: 4                       // 默认公式编号的最大引用层级
};

// 校验函数集合
function isValidFlag(f) {
    return f === true || f === false;
}
function isValidFirstOrMaxLevel(x) {
    return typeof x === 'number' && x >= 1 && x <= 6;
}
function isValidBlockIdSetting(x) {
    return typeof x === 'string' && (x === '' || x.startsWith('^'));
}
function isNonEmptyBlockId(x) {
    return x.length > 2 && x.startsWith('^');
}

/**
 * 生成用于匹配现有标题编号的正则表达式。
 * 这是一个能够匹配多级、混合样式（数字、字母、中文、圆圈数字）以及混合分隔符的强大正则。
 * * 结构解析:
 * ^\s{0,3}#+( )?               -> 匹配行首的 hash 符号 (H1-H6) 和可选空格
 * (                            -> 循环组开始
 * [Token]+ [Separator]+ ( )? -> 匹配 "1." 或 "A-" 等
 * )* -> 允许重复 (如 "1.1.A.")
 * ([Token]+)?                  -> 匹配末尾的编号 (如 "1.1.1" 中的最后一个 "1")
 * ( )? [Separator]? ( )+       -> 匹配编号结束后的分隔符和强制空格
 */
function getRegexForHeaderString(flags) {
    return /^\s{0,3}#+( )?([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&⓪]+[.:—\-]+( )?)*([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&⓪]+)?( )?[.:—\-]?( )+/g;
}

/**
 * 在标题行中查找编号前缀的范围。
 * 用于确定需要替换文本的起始和结束位置。
 * * @returns {{from: {line, ch}, to: {line, ch}} | undefined}
 */
function findRangeInHeaderString(lineText, lineNumber, flags) {
    const regex = getRegexForHeaderString(flags);
    if (!lineText)
        return undefined;
    const matches = lineText.match(regex);
    if (matches && matches.length !== 1) {
        // 调试日志：发现意外的标题格式
        console.log("Unexpected heading format: '" + lineText + "'");
        return undefined;
    }
    const match = matches ? matches[0] : '';
    const from = {
        line: lineNumber,
        ch: 0
    };
    const to = {
        line: lineNumber,
        ch: match.length
    };
    return { from, to };
}

// FrontMatter 键名常量
const AUTO_PART_KEY = 'auto';
const FIRST_LEVEL_PART_KEY = 'first-level';
const MAX_LEVEL_PART_KEY = 'max';
const SKIP_PART_KEY = 'skip';
const START_AT_PART_KEY = 'start-at';
const OFF_PART_KEY = 'off';

// FrontMatter 值校验正则
const rangeRegex = /^\d-\d$/; // e.g., "1-6"
const stylesRegex = /^[0-9aA\u4e00-\u9fa5\u2460-\u2473]{6}$/; // e.g., "1aA一①1"
const startValuesRegex = /^\d{6}$/; // e.g., "011111"
const separatorsRegex = /^[-:.—]{5}$/; // e.g., "-:.—-" (5个字符)

/**
 * 解析 FrontMatter 中的 'number headings' 属性。
 * 该属性使用紧凑格式存储设置，例如: "auto, 1-6, 111111, ......"
 */
function parseCompactFrontMatterSettings(fm) {
    const entry = obsidian.parseFrontMatterEntry(fm, 'number headings');
    if (entry) {
        const entryString = String(entry);
        const parts = entryString.split(',');
        let settings = Object.assign({}, DEFAULT_SETTINGS);

        // 状态标志，防止重复解析
        let rangeFound = false;
        let stylesFound = false;
        let separatorsFound = false;
        let startValuesFound = false;

        for (const part of parts) {
            const trimmedPart = part.trim();
            if (trimmedPart.length === 0)
                continue;

            if (trimmedPart === OFF_PART_KEY) {
                settings.off = true;
            }
            else if (trimmedPart === AUTO_PART_KEY) {
                settings.auto = true;
            }
            else if (trimmedPart.startsWith(FIRST_LEVEL_PART_KEY)) {
                const nstring = trimmedPart.substring(FIRST_LEVEL_PART_KEY.length + 1);
                const n = parseInt(nstring);
                if (isValidFirstOrMaxLevel(n)) settings.firstLevel = n;
            }
            else if (trimmedPart.startsWith(MAX_LEVEL_PART_KEY)) {
                const nstring = trimmedPart.substring(MAX_LEVEL_PART_KEY.length + 1);
                const n = parseInt(nstring);
                if (isValidFirstOrMaxLevel(n)) settings.maxLevel = n;
            }
            else if (trimmedPart.startsWith('equation-mode')) {
                const mode = trimmedPart.substring('equation-mode'.length + 1);
                if (mode === 'continuous' || mode === 'heading-based') {
                    settings.equationNumberingMode = mode;
                }
            }
            else if (!rangeFound && rangeRegex.test(trimmedPart)) {
                // 解析 "1-6" 格式的层级范围
                const rangeParts = trimmedPart.split('-');
                if (rangeParts.length === 2) {
                    const first = parseInt(rangeParts[0]);
                    const max = parseInt(rangeParts[1]);
                    if (isValidFirstOrMaxLevel(first)) settings.firstLevel = first;
                    if (isValidFirstOrMaxLevel(max)) settings.maxLevel = max;
                    rangeFound = true;
                }
            }
            else if (!stylesFound && stylesRegex.test(trimmedPart)) {
                // 解析 6字符样式串
                settings.headingStyles = trimmedPart.split('');
                stylesFound = true;
            }
            else if (!startValuesFound && startValuesRegex.test(trimmedPart)) {
                // 解析 6字符起始值串
                settings.headingStartValues = trimmedPart.split('');
                startValuesFound = true;
            }
            else if (!separatorsFound && separatorsRegex.test(trimmedPart)) {
                // 解析 5字符分隔符串 (映射到索引 1-5)
                const seps = trimmedPart.split('');
                settings.headingSeparators = ['', seps[0], seps[1], seps[2], seps[3], seps[4]];
                separatorsFound = true;
            }
        }
        return settings;
    }
    return undefined;
}

/**
 * 解析 FrontMatter 中的 'number formulas' 属性。
 * 独立处理公式相关的自动编号和模式设置。
 */
function parseFormulasFrontMatterSettings(fm) {
    const entry = obsidian.parseFrontMatterEntry(fm, 'number formulas');
    if (entry) {
        const entryString = String(entry);
        const parts = entryString.split(',');
        let settings = Object.assign({}, DEFAULT_SETTINGS);
        for (const part of parts) {
            const trimmedPart = part.trim();
            if (trimmedPart.length === 0)
                continue;
            if (trimmedPart === OFF_PART_KEY) {
                settings.off = true;
            }
            else if (trimmedPart === AUTO_PART_KEY) {
                settings.autoNumberFormulas = true;
            }
            else if (trimmedPart === 'continuous') {
                settings.equationNumberingMode = 'continuous';
            }
            // 解析 heading-based 及其参数
            else if (trimmedPart.startsWith('heading-based')) {
                settings.equationNumberingMode = 'heading-based';
                
                // 尝试提取括号内的数字，例如 heading-based(3)
                const match = trimmedPart.match(/heading-based\((\d+)\)/);
                if (match && match[1]) {
                    const depth = parseInt(match[1]);
                    // 确保深度在有效范围内 (1-6)
                    if (depth >= 1 && depth <= 6) {
                        settings.equationNumberingMaxDepth = depth;
                    }
                }
            }
        }
        return settings;
    }
    return undefined;
}

/**
 * 获取最终生效的设置。
 * 优先从 FrontMatter 获取，如果不存在则使用默认值或传入的替代设置。
 * 并且会将 'number formulas' 的设置合并进来。
 */
const getFrontMatterSettingsOrAlternative = ({ frontmatter }, alternativeSettings) => {
    if (frontmatter !== undefined) {
        // 解析标题设置
        const decompactedSettings = parseCompactFrontMatterSettings(frontmatter);
        // 解析公式设置
        const formulasSettings = parseFormulasFrontMatterSettings(frontmatter);

        if (decompactedSettings !== undefined) {
            // 合并
            if (formulasSettings !== undefined) {
                Object.assign(decompactedSettings, {
                    autoNumberFormulas: formulasSettings.autoNumberFormulas,
                    equationNumberingMode: formulasSettings.equationNumberingMode
                });
            }
            return decompactedSettings;
        }

        // 如果只有公式设置
        if (formulasSettings !== undefined) {
            return Object.assign(Object.assign({}, alternativeSettings), {
                autoNumberFormulas: formulasSettings.autoNumberFormulas,
                equationNumberingMode: formulasSettings.equationNumberingMode
            });
        }

        return alternativeSettings;
    }
    else {
        return alternativeSettings;
    }
};

/**
 * 将设置对象序列化为 'number headings' 的紧凑字符串。
 */
function settingsToCompactFrontMatterValue(settings) {
    if (settings.off) return OFF_PART_KEY;

    const parts = [];

    if (settings.auto) parts.push('auto');

    // 序列化级别范围
    if (settings.firstLevel !== 1 || settings.maxLevel !== 6) {
        parts.push(`${settings.firstLevel}-${settings.maxLevel}`);
    } else {
        parts.push('1-6');
    }

    // 序列化样式
    if (settings.headingStyles && settings.headingStyles.length >= 6) {
        parts.push(settings.headingStyles.join(''));
    } else {
        parts.push('1aA一①1');
    }

    // 序列化分隔符 (取索引1-5)
    if (settings.headingSeparators && settings.headingSeparators.length >= 6) {
        const sepsToSave = settings.headingSeparators.slice(1, 6);
        parts.push(sepsToSave.join(''));
    } else {
        parts.push(DEFAULT_SETTINGS.headingSeparators.slice(1, 6).join(''));
    }

    // 序列化起始值
    if (settings.headingStartValues && settings.headingStartValues.length >= 6) {
        parts.push(settings.headingStartValues.join(''));
    } else {
        parts.push('011111');
    }

    return parts.join(', ');
}

/**
 * 将设置对象序列化为 'number formulas' 的紧凑字符串。
 */
function formulasSettingsToCompactFrontMatterValue(settings) {
    if (settings.off) return OFF_PART_KEY;

    const parts = [];

    if (settings.autoNumberFormulas) parts.push('auto');

    if (settings.equationNumberingMode === 'heading-based') {
        // 始终输出 heading-based(X)，无论 X 是否为默认值
        // 如果 settings.equationNumberingMaxDepth 未定义，则回退到默认值 4
        const depth = settings.equationNumberingMaxDepth || 4;
        parts.push(`heading-based(${depth})`);
    } else {
        // 默认为 continuous
        parts.push('continuous');
    }
    return parts.join(', ');
}

/**
 * 保存设置到文件的 FrontMatter。
 */
const saveSettingsToFrontMatter = (fileManager, file, settings) => {
    fileManager.processFrontMatter(file, frontmatter => {
        const v = settingsToCompactFrontMatterValue(settings);
        frontmatter['number headings'] = v;

        const formulasValue = formulasSettingsToCompactFrontMatterValue(settings);
        frontmatter['number formulas'] = formulasValue;
    });
};

// ====================================================================================
// 编号控制面板 (UI)
// ====================================================================================

/**
 * 编号控制面板模态框。
 * 提供图形化界面供用户调整编号设置（样式、分隔符、范围、模式等），
 * 并执行手动编号或保存自动编号设置。
 */
class NumberingControlModal extends obsidian.Modal {
    constructor(app, config) {
        super(app);
        this.config = config;
        // 初始化本地状态，拷贝当前设置
        this.autoHeadings = config.settings.auto || false;
        this.autoFormulas = config.settings.autoNumberFormulas || false;
        this.equationMode = config.settings.equationNumberingMode || 'continuous';
        this.firstLevel = config.settings.firstLevel || 1;
        this.maxLevel = config.settings.maxLevel || 6;
        this.equationNumberingMaxDepth = config.settings.equationNumberingMaxDepth || 4;
        // 确保数组切片安全
        this.headingStyles = (config.settings.headingStyles || DEFAULT_SETTINGS.headingStyles).slice(0, 6);
        this.headingSeparators = (config.settings.headingSeparators || DEFAULT_SETTINGS.headingSeparators).slice(0, 6);
        this.headingStartValues = (config.settings.headingStartValues || DEFAULT_SETTINGS.headingStartValues).slice(0, 6);
    }

    onOpen() {
        const { contentEl, titleEl } = this;
        titleEl.setText('编号控制面板');

        // --- 顶部标签页切换 ---
        const tabs = contentEl.createEl('div', { cls: 'numbering-control-tabs' });
        const tabHeadings = tabs.createEl('button', { text: '手动编号' });
        const tabSettings = tabs.createEl('button', { text: '自动编号设置' });

        const headingsTabContent = contentEl.createEl('div', { cls: 'numbering-tab-content' });
        const settingsTabContent = contentEl.createEl('div', { cls: 'numbering-tab-content', attr: { style: 'display: none;' } });

        // 标签页逻辑
        tabHeadings.onclick = () => {
            headingsTabContent.style.display = 'block';
            settingsTabContent.style.display = 'none';
            tabHeadings.className = 'mod-cta';
            tabSettings.className = '';
        };

        tabSettings.onclick = () => {
            headingsTabContent.style.display = 'none';
            settingsTabContent.style.display = 'block';
            tabHeadings.className = '';
            tabSettings.className = 'mod-cta';
        };

        // --- 1. 手动编号选项卡 ---
        headingsTabContent.createEl('h3', { text: '手动编号选项' });
        const manualButtonsContainer = headingsTabContent.createEl('div', { cls: 'numbering-buttons-container' });

        // 按钮：仅标题
        manualButtonsContainer.createEl('button', { text: '为标题编号' }).onclick = () => {
            this.config.controlCallback('number-headings');
            this.close();
        };
        // 按钮：仅公式
        manualButtonsContainer.createEl('button', { text: '为公式编号' }).onclick = () => {
            this.config.controlCallback('number-formulas');
            this.close();
        };
        // 按钮：全部
        manualButtonsContainer.createEl('button', { text: '为标题和公式编号' }).onclick = () => {
            this.config.controlCallback('number-both');
            this.close();
        };
        // 按钮：移除
        manualButtonsContainer.createEl('button', { text: '删除所有编号' }).onclick = () => {
            this.config.controlCallback('remove-numbering');
            this.close();
        };

        // --- 2. 自动编号设置选项卡 ---
        settingsTabContent.createEl('h3', { text: '自动编号设置' });

        // 开关：自动标题
        const autoHeadingsSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        autoHeadingsSetting.createEl('label', { text: '自动为标题编号' });
        const autoHeadingsToggle = autoHeadingsSetting.createEl('input', { type: 'checkbox' });
        autoHeadingsToggle.checked = this.autoHeadings;
        autoHeadingsToggle.onchange = (e) => { this.autoHeadings = e.target.checked; };

        // 开关：自动公式
        const autoFormulasSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        autoFormulasSetting.createEl('label', { text: '自动为公式编号' });
        const autoFormulasToggle = autoFormulasSetting.createEl('input', { type: 'checkbox' });
        autoFormulasToggle.checked = this.autoFormulas;
        autoFormulasToggle.onchange = (e) => { this.autoFormulas = e.target.checked; };

        // 选择：公式模式
        const equationModeSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        equationModeSetting.createEl('label', { text: '公式编号模式' });
        const equationModeSelect = equationModeSetting.createEl('select');
        equationModeSelect.createEl('option', { text: '连续编号' }).value = 'continuous';
        equationModeSelect.createEl('option', { text: '基于标题编号' }).value = 'heading-based';
        equationModeSelect.value = this.equationMode;
        // 联动逻辑：当切换模式时，显示/隐藏深度设置
        equationModeSelect.onchange = (e) => { 
            this.equationMode = e.target.value; 
            if (this.equationMode === 'heading-based') {
                maxDepthSetting.style.display = 'flex';
            } else {
                maxDepthSetting.style.display = 'none';
            }
        };

        // 输入：Heading-based 模式的最大层级深度
        const maxDepthSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        // 初始显示状态依赖于当前模式
        maxDepthSetting.style.display = this.equationMode === 'heading-based' ? 'flex' : 'none';
        
        maxDepthSetting.createEl('label', { text: 'Heading-based 最大索引层级' });
        const maxDepthInput = maxDepthSetting.createEl('input', { 
            type: 'number', 
            attr: { min: 1, max: 6, style: 'width: 50px;' } 
        });
        // 从配置中读取当前值，默认4
        this.equationNumberingMaxDepth = this.config.settings.equationNumberingMaxDepth || 4; 
        maxDepthInput.value = String(this.equationNumberingMaxDepth);
        
        maxDepthInput.onchange = (e) => {
            const val = parseInt(e.target.value);
            if (!isNaN(val) && val >= 1 && val <= 6) {
                this.equationNumberingMaxDepth = val;
            }
        };

        // 输入：层级范围
        const rangeSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        rangeSetting.createEl('label', { text: '编号范围（第一级-最大级）' });
        const rangeContainer = rangeSetting.createEl('div');
        const firstLevelInput = rangeContainer.createEl('input', { type: 'number', attr: { min: 1, max: 6, style: 'width: 50px;' } });
        firstLevelInput.value = String(this.firstLevel);
        firstLevelInput.onchange = (e) => {
            const value = parseInt(e.target.value);
            if (!isNaN(value) && value >= 1 && value <= 6) this.firstLevel = value;
        };
        rangeContainer.createEl('span', { text: ' - ' });
        const maxLevelInput = rangeContainer.createEl('input', { type: 'number', attr: { min: 1, max: 6, style: 'width: 50px;' } });
        maxLevelInput.value = String(this.maxLevel);
        maxLevelInput.onchange = (e) => {
            const value = parseInt(e.target.value);
            if (!isNaN(value) && value >= 1 && value <= 6) this.maxLevel = value;
        };

        // 选择：各级样式
        const headingStylesSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        headingStylesSetting.createEl('label', { text: '各级标题类型（1-6级）' });
        const headingStylesContainer = headingStylesSetting.createEl('div', { cls: 'numbering-styles-container' });
        const styleOptions = ['1', 'a', 'A', '一', '①'];
        for (let i = 0; i < 6; i++) {
            const styleSelect = headingStylesContainer.createEl('select');
            styleOptions.forEach(option => { styleSelect.createEl('option', { text: option, value: option }); });
            styleSelect.value = this.headingStyles[i] || '1';
            styleSelect.onchange = (e) => { this.headingStyles[i] = e.target.value; };
        }

        // 选择：各级分隔符
        const separatorsSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        separatorsSetting.createEl('label', { text: '各级分隔符样式（H1-H2 ... H5-H6）' });
        const separatorsContainer = separatorsSetting.createEl('div', { cls: 'numbering-separators-container' });
        const separatorOptions = [
            { text: '短横线 (-)', value: '-' }, { text: '冒号 (:)', value: ':' },
            { text: '点 (.)', value: '.' }, { text: '长横线 (—)', value: '—' }
        ];
        for (let i = 1; i <= 5; i++) {
            const separatorSelect = separatorsContainer.createEl('select');
            separatorOptions.forEach(option => { separatorSelect.createEl('option', { text: option.text, value: option.value }); });
            separatorSelect.value = this.headingSeparators[i] || '-';
            separatorSelect.onchange = (e) => { this.headingSeparators[i] = e.target.value; };
        }

        // 输入：各级起始值
        const startValuesSetting = settingsTabContent.createEl('div', { cls: 'setting-item' });
        startValuesSetting.createEl('label', { text: '各级起始编号值（1-6级）' });
        const startValuesContainer = startValuesSetting.createEl('div', { cls: 'numbering-start-values-container' });
        for (let i = 0; i < 6; i++) {
            const startValueInput = startValuesContainer.createEl('input', { type: 'text', attr: { style: 'width: 40px; margin-right: 5px;' } });
            startValueInput.value = this.headingStartValues[i] || '1';
            startValueInput.onchange = (e) => { this.headingStartValues[i] = e.target.value.charAt(0) || '0'; };
        }

        // 提交按钮
        const saveSettingsButton = settingsTabContent.createEl('button', { text: '保存自动编号设置并应用一次' });
        saveSettingsButton.className = 'mod-cta';
        saveSettingsButton.onclick = () => {
            const options = {
                auto: this.autoHeadings,
                autoNumberFormulas: this.autoFormulas,
                equationNumberingMode: this.equationMode,
                firstLevel: this.firstLevel,
                maxLevel: this.maxLevel,
                headingStyles: this.headingStyles,
                headingSeparators: this.headingSeparators,
                headingStartValues: this.headingStartValues,
                equationNumberingMaxDepth: this.equationNumberingMaxDepth
            };
            this.config.controlCallback('set-auto', options);
            this.close();
        };

        // 默认激活
        tabHeadings.click();
    }

    onClose() {
        const { contentEl, titleEl } = this;
        contentEl.empty();
        titleEl.empty();
    }
}

/**
 * 显示编号控制面板并处理回调逻辑。
 */
function showNumberingControlPanel(app, settings) {
    const controlCallback = (action, options) => {
        const file = app.workspace.getActiveFile();
        if (!file) return;

        const viewInfo = getViewInfo(app);
        if (!viewInfo) return;

        switch (action) {
            case 'number-headings':
                updateHeadingNumbering(viewInfo, settings);
                break;
            case 'number-formulas':
                updateEquationNumbering(viewInfo, settings);
                break;
            case 'number-both':
                updateHeadingNumbering(viewInfo, settings);
                updateEquationNumbering(viewInfo, settings);
                break;
            case 'remove-numbering':
                removeHeadingNumbering(viewInfo);
                removeEquationNumbering(viewInfo);
                // 清除 FrontMatter
                app.fileManager.processFrontMatter(file, (frontmatter) => {
                    delete frontmatter['number headings'];
                    delete frontmatter['number formulas'];
                });
                break;
            case 'set-auto':
                // 保存设置并立即应用
                const newSettings = Object.assign({}, settings, options);
                saveSettingsToFrontMatter(app.fileManager, file, newSettings);
                if (newSettings.auto) {
                    updateHeadingNumbering(viewInfo, newSettings);
                }
                if (newSettings.autoNumberFormulas) {
                    updateEquationNumbering(viewInfo, newSettings);
                }
                break;
        }
    };

    const config = {
        message: `编号控制面板`,
        settings: settings,
        controlCallback
    };

    const leaf = app.workspace.activeLeaf;
    if (leaf) {
        new NumberingControlModal(app, config).open();
    }
}

function showNumberingDoneMessage(app, settings) {
    showNumberingControlPanel(app, settings);
}

// ====================================================================================
// 文本处理与更新逻辑 (核心功能)
// ====================================================================================

/**
 * 从标题对象中提取 "## " 前缀字符串。
 * 用于保留原本的 hash 符号和缩进。
 */
function makeHeadingHashString(editor, heading) {
    const regex = /^\s{0,4}#+/g;
    const headingLineString = editor.getLine(heading.position.start.line);
    if (!headingLineString)
        return undefined;
    const matches = headingLineString.match(regex);
    if (!matches)
        return undefined;
    if (matches.length !== 1) {
        console.log("Unexpected heading format: '" + headingLineString + "'");
        return undefined;
    }
    const match = matches[0];
    return match.trimLeft();
}

/**
 * 包装函数：在编辑器中查找特定标题的编号前缀范围。
 */
function findHeadingPrefixRange(editor, heading, flags) {
    const lineNumber = heading.position.start.line;
    const lineText = editor.getLine(lineNumber);
    return findRangeInHeaderString(lineText, lineNumber, flags);
}

/**
 * 经济地替换文本范围。
 * 仅在文本发生实际变化时才生成 change 对象，以防止污染撤销栈。
 */
function replaceRangeEconomically(editor, changes, range, text) {
    const previousText = editor.getRange(range.from, range.to);
    if (previousText !== text) {

        changes.push({
            text: text,
            from: range.from,
            to: range.to
        });
    }
}

/**
 * 更新文档中的标题编号。
 * 这是插件的核心逻辑函数之一。
 * * 算法概述:
 * 1. 遍历所有标题。
 * 2. 维护一个 `numberingStack` 栈，记录当前各级标题的 Token。
 * 3. 如果当前标题层级 > 上一个: 压入栈 (Push)，使用对应层级的起始值。
 * 4. 如果当前标题层级 < 上一个: 弹出栈 (Pop) 直到匹配，然后递增栈顶。
 * 5. 如果当前标题层级 = 上一个: 递增栈顶。
 * 6. 生成编号字符串并替换原有前缀。
 * * @returns {boolean} 如果发生了任何更改，返回 true
 */
const updateHeadingNumbering = (viewInfo, settings) => {
    var _a;
    if (!viewInfo)
        return false;
    const headings = (_a = viewInfo.data.headings) !== null && _a !== void 0 ? _a : [];
    const editor = viewInfo.editor;

    const codeRanges = getCodeBlockRanges(viewInfo.data);

    const supportFlags = { alphabet: true, roman: true };

    // 获取样式和起始值配置
    const headingStyles = settings.headingStyles || DEFAULT_SETTINGS.headingStyles;
    const headingStartValues = settings.headingStartValues || DEFAULT_SETTINGS.headingStartValues;

    // 状态初始化
    let previousLevel = settings.firstLevel - 1;
    let numberingStack = [];

    const changes = [];
    for (const heading of headings) {
        const level = heading.level;
        const lineNum = heading.position.start.line; // 获取行号
        const lineText = editor.getLine(lineNum);

        // 忽略代码块或表格中的标题
        if (isLineIgnored(lineNum, lineText, codeRanges)) {
            continue;
        }

        // 1. 处理跳过的层级 (settings.firstLevel 之前的)
        if (settings.firstLevel > level) {
            // 重置堆栈，因为编号序列被打断
            previousLevel = settings.firstLevel - 1;
            numberingStack = [];
            continue;
        }

        // 2. 处理用户指定跳过的特定标题 (如 "Appendix")
        if (settings.skipHeadings.length > 0) {
            if (heading.heading.endsWith(settings.skipHeadings)) {
                continue;
            }
        }

        // 3. 调整编号栈
        if (level === previousLevel) {
            // 同级：弹出并递增
            const x = numberingStack.pop();
            if (x !== undefined) {
                numberingStack.push(nextNumberingToken(x));
            }
        }
        else if (level < previousLevel) {
            // 升级 (H3 -> H2)：弹出多余层级，递增上一级
            for (let i = previousLevel; i > level; i--) {
                numberingStack.pop();
            }
            const x = numberingStack.pop();
            if (x !== undefined) {
                numberingStack.push(nextNumberingToken(x));
            }
        }
        else if (level > previousLevel) {
            // 降级 (H2 -> H3)：填充中间层级
            for (let i = previousLevel; i < level; i++) {
                const styleIndex = Math.min(i, headingStyles.length - 1);
                // 使用对应层级的样式和起始值初始化新的 Token
                numberingStack.push(firstNumberingTokenInStyle(headingStyles[styleIndex], headingStartValues[styleIndex]));
            }
        }

        // 更新前置层级记录
        previousLevel = level;

        // 超过最大层级不编号
        if (level > settings.maxLevel) {
            continue;
        }

        // 4. 应用更改
        const prefixRange = findHeadingPrefixRange(editor, heading, supportFlags);
        if (prefixRange === undefined) continue;

        const headingHashString = makeHeadingHashString(editor, heading);
        if (headingHashString === undefined) continue;

        // 构建编号字符串
        const prefixString = makeNumberingString(numberingStack, settings.headingSeparators || []);
        const separators = settings.headingSeparators || DEFAULT_SETTINGS.headingSeparators;
        const separator = separators[0] || ''; // H1 前缀分隔符

        // 记录更改
        replaceRangeEconomically(editor, changes, prefixRange, headingHashString + prefixString + separator + ' ');
    }

    // 批量执行事务
    if (changes.length > 0) {
        console.log('Number Headings Plugin: Applying headings numbering changes:', changes.length);

        editor.transaction({
            changes: changes
        });
        return true;
    }
    return false;
};

/**
 * 移除所有标题编号。
 * 将标题还原为仅剩 hash 符号 (例如 "## 1.1 Title" -> "## Title")。
 */
const removeHeadingNumbering = (viewInfo) => {
    var _a;
    if (!viewInfo)
        return;
    const headings = (_a = viewInfo.data.headings) !== null && _a !== void 0 ? _a : [];
    const editor = viewInfo.editor;
    const changes = [];
    for (const heading of headings) {
        const prefixRange = findHeadingPrefixRange(editor, heading, { alphabet: true, roman: true });
        if (prefixRange === undefined)
            return;
        const headingHashString = makeHeadingHashString(editor, heading);
        if (headingHashString === undefined)
            return;
        replaceRangeEconomically(editor, changes, prefixRange, headingHashString + ' ');
    }
    if (changes.length > 0) {
        editor.transaction({
            changes: changes
        });
    }
};

/**
 * 更新公式编号。
 * 支持 MathJax 块 ($$ ... $$) 的自动编号。
 * * 模式:
 * 1. continuous: 全文连续编号 (1, 2, 3...)
 * 2. heading-based: 基于最近一个标题编号 (1.1-1, 1.1-2...)
 * * @returns {boolean} 如果发生更改返回 true
 */
const updateEquationNumbering = ({ editor, data }, settings) => {
    const lineCount = editor.lineCount();
    const changes = [];

    // 获取代码块范围
    const codeRanges = getCodeBlockRanges(data);

    // 计数器状态
    let equationCounter = 1;
    let currentHeadingNumber = '';
    const headingFormulaCounters = {};

    // 1. 扫描所有 '$$' 位置
    const dollarPositions = [];
    for (let i = 0; i < lineCount; i++) {
        const line = editor.getLine(i);
        
        // 检查该行是否应被忽略
        if (isLineIgnored(i, line, codeRanges)) {
            continue; 
        }

        let pos = -1;
        while ((pos = line.indexOf('$$', pos + 1)) !== -1) {
            dollarPositions.push({ line: i, ch: pos });
        }
    }

    // 2. 配对 '$$' 并处理其中的公式
    for (let i = 0; i < dollarPositions.length - 1; i += 2) {
        const start = dollarPositions[i];
        const end = dollarPositions[i + 1];

        // 提取公式文本内容
        let formulaContent = '';
        if (start.line === end.line) {
            const line = editor.getLine(start.line);
            formulaContent = line.substring(start.ch, end.ch + 2);
        } else {
            const startLine = editor.getLine(start.line);
            formulaContent += startLine.substring(start.ch) + '\n';
            for (let lineNum = start.line + 1; lineNum < end.line; lineNum++) {
                formulaContent += editor.getLine(lineNum) + '\n';
            }
            const endLine = editor.getLine(end.line);
            formulaContent += endLine.substring(0, end.ch + 2);
        }

        // 检查是否已有 \tag{}
        const tagRegex = /\\tag\{([^}]+)\}/;
        const hasTag = formulaContent.match(tagRegex);

        // 3. 如果是基于标题的模式，查找最近的前置标题
        currentHeadingNumber = '';
        if (settings.equationNumberingMode === 'heading-based') {
            const headings = data.headings || [];
            let currentHeading = null;
            
            // 获取配置的深度限制，默认为 4
            const maxDepth = settings.equationNumberingMaxDepth || 4;

            // 倒序查找最近标题
            let searchIndex = -1;
            
            // 第一步：找到物理位置上最近的标题
            for (let j = headings.length - 1; j >= 0; j--) {
                if (headings[j].position.start.line <= start.line) {
                    searchIndex = j;
                    break;
                }
            }

            // 第二步：如果找到了标题，但它太深了（比如是Level 5，限制是4），则继续往上找它的父级
            if (searchIndex !== -1) {
                // 从当前找到的位置开始，继续向前（向上）查找，直到找到 level <= maxDepth 的标题
                for (let k = searchIndex; k >= 0; k--) {
                    if (headings[k].level <= maxDepth) {
                        currentHeading = headings[k];
                        break;
                    }
                    // 如果一直往前找直到开头都没找到符合条件的（比如全文只有 Level 5），
                    // currentHeading 将保持 null 或者你也可以选择保留最初找到的那个深层标题（取决于容错策略）
                    // 按照需求逻辑，应该是不索引五级六级，意味着必须归属到四级及以上。
                }
            }
            
            if (currentHeading) {
                const headingLine = editor.getLine(currentHeading.position.start.line);
                // 提取标题中的编号部分
                const numberExtractRegex = /^\s{0,4}#+\s*([0-9a-zA-Z\u4e00-\u9fa5\u2460-\u2473&⓪].*?)(\s|$)/;
                const headingMatch = headingLine.match(numberExtractRegex);

                if (headingMatch && headingMatch[1]) {
                    currentHeadingNumber = headingMatch[1].trim();
                    // 去除末尾分隔符
                    if (['.', ':', '—', '-'].some(c => currentHeadingNumber.endsWith(c))) {
                        currentHeadingNumber = currentHeadingNumber.slice(0, -1);
                    }

                    if (!headingFormulaCounters[currentHeadingNumber]) {
                        headingFormulaCounters[currentHeadingNumber] = 1;
                    }
                }
            }
        }

        // 4. 生成新编号
        let equationNumber;
        if (settings.equationNumberingMode === 'heading-based' && currentHeadingNumber) {
            equationNumber = `${currentHeadingNumber}-${headingFormulaCounters[currentHeadingNumber]}`;
            headingFormulaCounters[currentHeadingNumber]++;
        } else {
            equationNumber = `${equationCounter}`;
            equationCounter++;
        }

        // 5. 应用编号 (插入或替换)
        if (!hasTag) {
            // 插入模式：在末尾 $$ 前插入 \tag{...}
            const endLine = editor.getLine(end.line);
            const beforeDollars = endLine.substring(0, end.ch);
            const afterDollars = endLine.substring(end.ch);
            const newLine = beforeDollars + ` \\tag{${equationNumber}}` + afterDollars;

            changes.push({
                from: { line: end.line, ch: 0 },
                to: { line: end.line, ch: endLine.length },
                text: newLine
            });

        } else {
            // 替换模式：更新现有的 \tag{...}
            const updatedContent = formulaContent.replace(tagRegex, `\\tag{${equationNumber}}`);

            if (updatedContent !== formulaContent) {
                if (start.line === end.line) {
                    const line = editor.getLine(start.line);
                    const beforeFormula = line.substring(0, start.ch);
                    const afterFormula = line.substring(end.ch + 2);

                    changes.push({
                        from: { line: start.line, ch: 0 },
                        to: { line: start.line, ch: line.length },
                        text: beforeFormula + updatedContent + afterFormula
                    });
                } else {
                    changes.push({
                        from: { line: start.line, ch: start.ch },
                        to: { line: end.line, ch: end.ch + 2 },
                        text: updatedContent
                    });
                }
            }
        }
    }

    if (changes.length > 0) {
        console.log('Number Headings Plugin: Applying equation numbering changes:', changes.length);

        editor.transaction({
            changes: changes
        });
        return true;
    }
    return false;
};

/**
 * 移除公式编号。
 * 安全地删除所有公式块中的 \tag{...} 标记。
 */
const removeEquationNumbering = (viewInfo) => {
    if (!viewInfo)
        return;

    const editor = viewInfo.editor;
    const changes = [];
    const lineCount = editor.lineCount();
    const tagRegex = /\s*\\tag\{[^}]*\}/;

    // 1. 定位所有公式块
    const dollarPositions = [];
    for (let i = 0; i < lineCount; i++) {
        const line = editor.getLine(i);
        let pos = -1;
        while ((pos = line.indexOf('$$', pos + 1)) !== -1) {
            dollarPositions.push({ line: i, ch: pos });
        }
    }

    // 2. 倒序遍历，防止删除文本导致后续行号/索引失效
    for (let i = dollarPositions.length - 2; i >= 0; i -= 2) {
        const start = dollarPositions[i];
        const end = dollarPositions[i + 1];

        // 3. 在公式块内部查找 tag 并删除
        for (let j = start.line; j <= end.line; j++) {
            const line = editor.getLine(j);

            let searchStartCh = 0;
            let searchEndCh = line.length;

            // 确定查找范围 (排除 $$)
            if (j === start.line) searchStartCh = start.ch + 2;
            if (j === end.line) searchEndCh = end.ch;
            if (j === start.line && j === end.line) {
                searchStartCh = start.ch + 2;
                searchEndCh = end.ch;
            }

            if (searchStartCh >= searchEndCh) continue;

            const contentToSearch = line.substring(searchStartCh, searchEndCh);

            if (tagRegex.test(contentToSearch)) {
                const newContent = contentToSearch.replace(tagRegex, '');
                changes.push({
                    from: { line: j, ch: searchStartCh },
                    to: { line: j, ch: searchEndCh },
                    text: newContent
                });
                break; // 假设每个公式只有一个 tag
            }
        }
    }

    if (changes.length > 0) {
        editor.transaction({
            changes: changes
        });
    }
};

// ====================================================================================
// 插件设置面板 (Obsidian 设置页)
// ====================================================================================

class NumberHeadingsPluginSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl('h2', { text: 'Number Headings - Settings' });
        containerEl.createEl('div', { text: '这些设置将用作编号控制面板的默认值。要为特定文档设置编号，请使用编号控制面板。' });
        containerEl.createEl('br', {});

        // 设置项：第一级别
        new obsidian.Setting(containerEl)
            .setName('第一标题级别')
            .setDesc('编号起始的标题级别')
            .addSlider(slider => slider
                .setLimits(1, 6, 1)
                .setValue(this.plugin.settings.firstLevel)
                .setDynamicTooltip()
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.firstLevel = value;
                    yield this.plugin.saveSettings();
                })));

        // 设置项：最大级别
        new obsidian.Setting(containerEl)
            .setName('最大标题级别')
            .setDesc('编号的最大标题级别')
            .addSlider(slider => slider
                .setLimits(1, 6, 1)
                .setValue(this.plugin.settings.maxLevel)
                .setDynamicTooltip()
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.maxLevel = value;
                    yield this.plugin.saveSettings();
                })));

        // 设置项：标题样式 (动态生成下拉框)
        new obsidian.Setting(containerEl)
            .setName('各级标题类型')
            .setDesc('定义1-6级标题的编号类型')
            .setClass('numbering-setting-item-styles')
            .then(setting => {
                const styleOptions = ['1', 'a', 'A', '一', '①'];
                const container = setting.controlEl;
                container.style.display = 'flex';
                container.style.flexWrap = 'wrap';

                for (let i = 0; i < 6; i++) {
                    const select = container.createEl('select');
                    select.style.marginRight = '5px';
                    select.style.marginBottom = '5px';
                    styleOptions.forEach(option => {
                        select.createEl('option', { text: option, value: option });
                    });
                    select.value = this.plugin.settings.headingStyles[i] || '1';
                    select.onchange = (e) => __awaiter(this, void 0, void 0, function* () {
                        this.plugin.settings.headingStyles[i] = e.target.value;
                        yield this.plugin.saveSettings();
                    });
                }
            });

        // 设置项：分隔符 (动态生成下拉框)
        new obsidian.Setting(containerEl)
            .setName('各级分隔符样式')
            .setDesc('定义 H1-H2 ... H5-H6 之间的5个分隔符')
            .setClass('numbering-setting-item-styles')
            .then(setting => {
                const separatorOptions = [
                    { text: '短横线 (-)', value: '-' },
                    { text: '冒号 (:)', value: ':' },
                    { text: '点 (.)', value: '.' },
                    { text: '长横线 (—)', value: '—' }
                ];
                const container = setting.controlEl;
                container.style.display = 'flex';
                container.style.flexWrap = 'wrap';

                for (let i = 1; i <= 5; i++) {
                    const select = container.createEl('select');
                    select.style.marginRight = '5px';
                    select.style.marginBottom = '5px';
                    separatorOptions.forEach(option => {
                        select.createEl('option', { text: option.text, value: option.value });
                    });
                    select.value = this.plugin.settings.headingSeparators[i] || '-';
                    select.onchange = (e) => __awaiter(this, void 0, void 0, function* () {
                        this.plugin.settings.headingSeparators[i] = e.target.value;
                        yield this.plugin.saveSettings();
                    });
                }
            });

        // 设置项：起始编号
        new obsidian.Setting(containerEl)
            .setName('各级起始编号')
            .setDesc('定义1-6级标题的起始编号值')
            .setClass('numbering-setting-item-styles')
            .then(setting => {
                const container = setting.controlEl;
                container.style.display = 'flex';
                container.style.flexWrap = 'wrap';

                for (let i = 0; i < 6; i++) {
                    const input = container.createEl('input', { type: 'text', attr: { style: 'width: 40px; margin-right: 5px; margin-bottom: 5px;' } });
                    input.value = this.plugin.settings.headingStartValues[i] || '1';
                    input.onchange = (e) => __awaiter(this, void 0, void 0, function* () {
                        this.plugin.settings.headingStartValues[i] = e.target.value.charAt(0) || '0';
                        yield this.plugin.saveSettings();
                    });
                }
            });

        // 设置项：公式编号模式
        new obsidian.Setting(containerEl)
            .setName('默认公式编号模式')
            .setDesc('定义公式编号方式。连续编号：在整个文档中递增编号。基于标题编号：基于前一个标题编号（例如，1.1, 1.2）。')
            .addDropdown(dropdown => dropdown
                .addOption('continuous', '连续编号')
                .addOption('heading-based', '基于标题编号')
                .setValue(this.plugin.settings.equationNumberingMode)
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.equationNumberingMode = value;
                    yield this.plugin.saveSettings();
                })));

        // 设置项：公式编号最大层级
        new obsidian.Setting(containerEl)
            .setName('公式编号最大索引层级')
            .setDesc('仅在 Heading-based 模式下有效。若标题层级深于此值，将使用该层级的父标题进行编号索引。')
            .addSlider(slider => slider
                .setLimits(1, 6, 1)
                .setValue(this.plugin.settings.equationNumberingMaxDepth || 4)
                .setDynamicTooltip()
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    this.plugin.settings.equationNumberingMaxDepth = value;
                    yield this.plugin.saveSettings();
                })));

        // 设置项：刷新间隔
        new obsidian.Setting(containerEl)
            .setName('自动刷新间隔（毫秒）')
            .setDesc('自动编号的刷新间隔时间（毫秒，例如 500 表示 0.5 秒）')
            .addText(text => text
                .setValue(String(this.plugin.settings.refreshInterval))
                .onChange((value) => __awaiter(this, void 0, void 0, function* () {
                    const interval = parseInt(value);
                    if (!isNaN(interval) && interval > 0) {
                        this.plugin.settings.refreshInterval = interval;
                        yield this.plugin.saveSettings();
                    }
                })));
    }
}

// ====================================================================================
// 插件主类
// ====================================================================================

class NumberHeadingsPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.info('Loading Number Headings Plugin, version ' + this.manifest.version);
            yield this.loadSettings();

            // 自动更新定时器引用
            this.autoUpdateTimeout = null;

            // 注册命令：打开编号控制面板
            this.addCommand({
                id: 'number-control',
                name: '编号控制',
                checkCallback: (checking) => {
                    if (checking)
                        return isViewActive(this.app);
                    const viewInfo = getViewInfo(this.app);
                    if (viewInfo) {
                        const settings = getFrontMatterSettingsOrAlternative(viewInfo.data, this.settings);
                        if (settings.off)
                            return false;
                        showNumberingControlPanel(this.app, settings);
                    }
                    return false;
                }
            });

            // 注册设置页
            this.addSettingTab(new NumberHeadingsPluginSettingTab(this.app, this));

            // 注册焦点事件以驱动自动更新
            this.registerEditorFocusEvents();
        });
    }

    /**
     * 注册编辑器焦点事件监听器。
     * 逻辑：当窗口失焦时启动计时器，超时后执行自动更新；如果窗口重新获得焦点，则取消更新。
     */
    registerEditorFocusEvents() {
        // 1. DOM 失焦 (Blur) -> 开启计时器
        this.registerDomEvent(window, 'blur', () => {
            this.handleBlur();
        });

        // 2. DOM 聚焦 (Focus) -> 打断计时器
        this.registerDomEvent(window, 'focus', () => {
            this.handleFocus();
        });
    }

/**
     * 处理失焦事件。
     * 逻辑说明：
     * 每次失焦时，都会重新获取【当前活跃文档】的配置。
     * 1. 如果当前文档未开启自动编号 -> 直接返回 (无 Log，无计时器)。
     * 2. 如果当前文档开启了自动编号 -> 启动计时器。
     * 这种“即时检查”机制天然支持标签页切换。
     */
    handleBlur() {
        // 1. 获取当前活跃视图 (用户切换标签页后，这里获取的就是新页面的信息)
        const viewInfo = getViewInfo(this.app);
        
        // 如果当前没有打开 Markdown 文档，直接退出
        if (!viewInfo || !viewInfo.data) return;

        // 2. 解析当前文档的 FrontMatter 配置
        // 这一步是关键：它会读取当前文档的 YAML 设置
        const settings = getFrontMatterSettingsOrAlternative(viewInfo.data, this.settings);

        // 3. 智能阻断：
        // 如果全局开关是 off，或者 (标题自动编号关 AND 公式自动编号关)
        // 那么立刻停止，不产生任何 Log，也不启动计时器
        if (settings.off || (!settings.auto && !settings.autoNumberFormulas)) {
            return;
        }

        // --- 只有配置了自动编号的文档才会运行到这里 ---

        this.clearAutoUpdateTimer();

        // 获取延迟时间
        const delay = (this.settings.refreshInterval || 5000);
        console.log(`Number Headings Plugin: Blurred. Timer started for ${delay}ms.`);

        this.autoUpdateTimeout = window.setTimeout(() => {
            this.performAutoUpdate();
        }, delay);
    }

    /**
     * 处理聚焦事件。
     * 如果用户在倒计时结束前回来，则取消更新，防止干扰用户。
     */
    handleFocus() {
        if (this.autoUpdateTimeout) {
            console.log('Number Headings Plugin: Focused. Timer cancelled.');
            this.clearAutoUpdateTimer();
        }
    }

    clearAutoUpdateTimer() {
        if (this.autoUpdateTimeout) {
            clearTimeout(this.autoUpdateTimeout);
            this.autoUpdateTimeout = null;
        }
    }

    /**
     * 执行自动更新逻辑。
     * 包含快照光标位置、执行更新、并在检测到变更后恢复光标的完整流程。
     */
    performAutoUpdate() {
        const viewInfo = getViewInfo(this.app);
        if (!viewInfo || !viewInfo.editor) return;

        const settings = getFrontMatterSettingsOrAlternative(viewInfo.data, this.settings);

        // 检查是否启用了自动功能
        if (settings.off || (!settings.auto && !settings.autoNumberFormulas)) {
            return;
        }

        const editor = viewInfo.editor;

        // 步骤 1: 记录更新前状态 (光标和滚动位置)
        const cursorBefore = editor.getCursor();
        const scrollBefore = editor.getScrollInfo();

        console.log('Number Headings Plugin: executing auto-update check...');

        let isChanged = false;

        try {
            // A. 尝试更新标题
            if (settings.auto) {
                if (updateHeadingNumbering(viewInfo, settings)) {
                    isChanged = true;
                }
            }

            // B. 尝试更新公式
            if (settings.autoNumberFormulas) {
                if (updateEquationNumbering(viewInfo, settings)) {
                    isChanged = true;
                }
            }

        } catch (e) {
            console.error("Number Headings Plugin: Error during update logic", e);
            this.autoUpdateTimeout = null;
            return;
        }

        // 步骤 2: 如果发生变更，恢复用户视角
        if (isChanged) {
            console.log('Number Headings Plugin: Changes detected. Restoring cursor and scroll position.');

            if (typeof restoreCursor === 'function') {
                restoreCursor(editor, cursorBefore);
            } else {
                editor.setCursor(cursorBefore);
            }

            editor.scrollTo(scrollBefore.left, scrollBefore.top);
        } else {
            console.log('Number Headings Plugin: No changes needed.');
        }

        this.autoUpdateTimeout = null;
    }

    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }

    onunload() {
        this.clearAutoUpdateTimer();
    }
}

module.exports = NumberHeadingsPlugin;
